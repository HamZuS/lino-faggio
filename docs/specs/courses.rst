.. _voga.specs.courses:

=======
Courses
=======

.. to test only this doc:

    $ python setup.py test -s tests.DocsTests.test_courses

    >>> from lino import startup
    >>> startup('lino_voga.projects.docs.settings.doctests')
    >>> from lino.api.doctest import *
    
    
This document analyzes the demo courses generated by 
:mod:`lino_voga.lib.voga.fixtures.buche`.


Pupils and teachers
===================

Lino Voga adds specific models for teachers and pupils.
A teacher is a person with a `teacher_type`.
A pupil is a person with a `pupil_type`.

The :mod:`lino_cosi.lib.courses` plugin has two settings
:attr:`teacher_model<lino_cosi.lib.courses.Plugin.teacher_model>`
and
:attr:`pupil_model<lino_cosi.lib.courses.Plugin.pupil_model>`:


>>> dd.plugins.courses.teacher_model
'courses.Teacher'

>>> dd.plugins.courses.pupil_model
'courses.Pupil'

>>> ses = rt.login('robin')

>>> ses.show(courses.PupilTypes)
==== =========== =============
 ID   Reference   Designation
---- ----------- -------------
 1    M           Member
 2    H           Helper
 3    N           Non-member
==== =========== =============
<BLANKLINE>

>>> ses.show(courses.TeacherTypes)
==== =========== ==================
 ID   Reference   Designation
---- ----------- ------------------
 1    S           Independant
 2    EP          Voluntary (flat)
 3    ER          Voluntary (real)
 4    LBA         LEA
==== =========== ==================
<BLANKLINE>


The fee of a course
===================

Per course and per enrolment we get a new field :attr:`fee`.

Number of places
================

The :attr:`max_places<lino_cosi.lib.courses.models.Course.max_places>`
(:ddref:`courses.Course.max_places`) field of a *course* contains the
number of available places.

It is a simple integer value and expresses an *absolute* upper limit
which cannot be bypassed. Lino will refuse to confirm an enrolment if
this limit is reached. Here is a user statement about this:

    Also im Prinzip nehmen wir bei den Computerkursen maximal 10 Leute
    an. Da wir aber überall über 12 Geräte verfügen, können wir immer
    im Bedarfsfall um 2 Personen aufstocken. Also bei PC-Kursen setzen 
    wir das Maximum immer auf 12. Als Regel gilt dann, dass wir immer nur
    10 annehmen, aber falls unbedingt erforderlich auf 12 gehen
    können.

Every *enrolment* has a field
:attr:`places<lino_cosi.lib.courses.models.Enrolment.places>`
(:ddref:`courses.Enrolment.places`) which expresses how many places
this enrolment takes. This is usually 1, but for certain types of
courses, e.g. bus travels, it can happen that one enrolment is for two
or more persons.


Automatic calender events
=========================

The first demo course starts on December 2, 2013:

>>> obj = courses.Course.objects.get(pk=3)
>>> print(obj)
comp (12/2/13 Computer room)


..

    Repair from previous incomplete test runs.

    >>> obj.do_update_events(ses)
    >>> ses.response['success']
    True



>>> ses.show(cal.EventsByController, obj, column_names="when_text state")
====================== ===========
 When                   State
---------------------- -----------
 Mon 12/2/13 (13:30)    Suggested
 Mon 12/9/13 (13:30)    Suggested
 Mon 12/16/13 (13:30)   Suggested
 Mon 12/23/13 (13:30)   Suggested
 Mon 12/30/13 (13:30)   Suggested
 Mon 1/6/14 (13:30)     Suggested
 Mon 1/13/14 (13:30)    Suggested
 Mon 1/20/14 (13:30)    Suggested
====================== ===========
<BLANKLINE>


We run the UpdateEvents action a first time and verify that the events
remain unchanged (if the following fails, make sure you've run
:cmd:`fab initdb` before running :cmd:`fab test`).

>>> # import logging
>>> # logger = logging.getLogger('lino')
>>> # logger.setLevel('DEBUG')
>>> res = ses.run(obj.do_update_events)
>>> res['success']
True
>>> print(res['info_message'])
Update Events for comp (12/2/13 Computer room)...
Generating events between 2013-12-02 and 2019-06-15.
8 row(s) have been updated.
>>> ses.show(cal.EventsByController, obj, column_names="when_text state")
====================== ===========
 When                   State
---------------------- -----------
 Mon 12/2/13 (13:30)    Suggested
 Mon 12/9/13 (13:30)    Suggested
 Mon 12/16/13 (13:30)   Suggested
 Mon 12/23/13 (13:30)   Suggested
 Mon 12/30/13 (13:30)   Suggested
 Mon 1/6/14 (13:30)     Suggested
 Mon 1/13/14 (13:30)    Suggested
 Mon 1/20/14 (13:30)    Suggested
====================== ===========
<BLANKLINE>

We select the event no 4 (2013-12-23):

>>> qs = obj.get_existing_auto_events()
>>> e = qs.get(start_date=i2d(20131223))

Yes, the state is "suggested":

>>> print(e.state)
Suggested

Now we move that to the week after:

>>> e.move_next(ses)
>>> ses.response['success']
True
>>> print(ses.response['info_message'])
Update Events for comp (12/2/13 Computer room)...
Generating events between 2013-12-02 and 2019-06-15.
8 row(s) have been updated.
Move down for Course #3 Hour 4...
1 row(s) have been updated.


The state is now "draft":

>>> print(e.state)
Draft

We have now two events on 20131230:

>>> ses.show(cal.EventsByController, obj, column_names="when_text state")
====================== ===========
 When                   State
---------------------- -----------
 Mon 12/2/13 (13:30)    Suggested
 Mon 12/9/13 (13:30)    Suggested
 Mon 12/16/13 (13:30)   Suggested
 Mon 12/30/13 (13:30)   Draft
 Mon 12/30/13 (13:30)   Suggested
 Mon 1/6/14 (13:30)     Suggested
 Mon 1/13/14 (13:30)    Suggested
 Mon 1/20/14 (13:30)    Suggested
====================== ===========
<BLANKLINE>

To solve that, we must click on the lightning button:

>>> obj.do_update_events(ses)
>>> ses.response['success']
True

>>> ses.show(cal.EventsByController, obj, column_names="when_text state")
====================== ===========
 When                   State
---------------------- -----------
 Mon 12/2/13 (13:30)    Suggested
 Mon 12/9/13 (13:30)    Suggested
 Mon 12/16/13 (13:30)   Suggested
 Mon 12/30/13 (13:30)   Draft
 Mon 1/6/14 (13:30)     Suggested
 Mon 1/13/14 (13:30)    Suggested
 Mon 1/20/14 (13:30)    Suggested
 Mon 1/27/14 (13:30)    Suggested
====================== ===========
<BLANKLINE>

Click on the "Reset" button:

>>> e.state = cal.EventStates.suggested
>>> e.save()

Re-run UpdateEvents to restore original state:

>>> res = ses.run(obj.do_update_events)
>>> res['success']
True
>>> ses.show(cal.EventsByController, obj, column_names="when_text state")
====================== ===========
 When                   State
---------------------- -----------
 Mon 12/2/13 (13:30)    Suggested
 Mon 12/9/13 (13:30)    Suggested
 Mon 12/16/13 (13:30)   Suggested
 Mon 12/23/13 (13:30)   Suggested
 Mon 12/30/13 (13:30)   Suggested
 Mon 1/6/14 (13:30)     Suggested
 Mon 1/13/14 (13:30)    Suggested
 Mon 1/20/14 (13:30)    Suggested
====================== ===========
<BLANKLINE>



The following is waiting for :ticket:`526` before it can work:

>>> # demo_get('robin', 'choices/courses/Courses/city', 'bla', 0)


There are three courses in the course line "Europe":

>>> courses.Line.objects.get(pk=1)
Line #1 ('Europe')
        
>>> ContentType = rt.modules.contenttypes.ContentType
>>> json_fields = 'count rows title success no_data_text param_values'
>>> kw = dict(fmt='json', limit=10, start=0)
>>> mt = ContentType.objects.get_for_model(courses.Line).pk
>>> demo_get('robin',
...          'api/courses/CoursesByLine', json_fields, 1, mt=mt, mk=1, **kw)



